# 3. DIY Static Site Generation

Picking one of the available static site generatores almost feels like deciding on a CMS 10 years ago when the choices were Wordpress, Joomla, Drupal, etc.
The aforementioned eight workflow requirements don't look overly complicated, let's try to that tacle them one at a time.

## 1. Writing content in Markdown

That's really easy, just install VSCode. Here is a short post showing [How to Use Markdown in VSCode](https://www.freecodecamp.org/news/how-to-use-markdown-in-vscode/).
Create a new folder (e.g. posts) and start putting markdown files (files with an _md_ extension) into it.

## 2. Content Meta Data

Let's add some site metadata to the `context.json` file. I would suggest something like this:

```json
{
  "site_dir": "public",
  "templates_dir": "templates",
  "posts_dir": "posts",
  "static_dirs": ["assets"],
  "copyright_year": "2024",
  "title": "Static Web Site Generator Demo",
  "description": "This site was generated by jinja templates.",

  "content": {
    "posts": [
      {
        "name": "triumph",
        "cover": "triumph.png",
        "title": "The Beginner's Triumph.",
        "summary": "Emma embarks on her programming journey with Python and triumphs over her first coding challenges.",
        "cat": "software",
        "featured": true
      },
      {
        "name": "dilemma",
        "cover": "dilemma.png",
        "title": "The Debugger's Dilemma",
        "summary": "Liam, a seasoned developer, solves a persistent bug by taking a step back and rethinking his approach.",
        "cat": "software",
        "featured": false
      }
    ]
  }
}
```

## 3. Presentation Layer

There are quite a few web sites providing access to HTML site templates. Some provide great customizable templates even for free.
Here are a few examples:

1. [HTML5up](https://html5up.net) - Spiffy HTML5 site templates that are fully responsive built on HTML5 + CSS3, and 100% free under the Creative Commons License.
1. [Lexington Themes](https://lexingtonthemes.com) - free and premium multipage themes and UI Kits
1. [Code Stitch](https://www.codestitch.app) - HTML and CSS Template Library
1. [envato](https://themeforest.net/category/site-templates) - HTML Templates and HTML Website Templates
1. [Pure CSS](https://purecss.io) - A set of small, responsive CSS modules that you can use in every web project.
1. [W3.CSS Templates](https://www.w3schools.com/w3css/w3css_templates.asp) - Simple responsive W3.CSS website templates

### Big Idea

The big idea is to modify an existing HTML site template, by replacing some `html` with `jinja` code, bascially turning html files into jinja files.

Jinja is templating language for Python developers. A template contains variables which are replaced by the values which are passed in when the template is rendered. Special placeholders in the template allow writing code similar to Python syntax. For example

#### Delimiters

- {%....%} are for statements
- {{....}} are expressions used to print to template output

For example, after pip-installing jinja2, the following Python program:

```python
from jinja2 import Template
from json import load

jinja_template = '''
<!DOCTYPE html>
<html>
<head>
 <title>{{ title }}</title>
</head>
<body>
  <ol>
    {% for post in content.posts if post.cat == "software" %}
      <li>{{ post.title }}</li>
    {% endfor %}
  </ol>
</body>
</html>
'''
with open('context.json') as json_file:
    context = load(json_file)
html = Template(jinja_template).render(context)
print(html)
```

prints this output:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Static Web Site Generator Demo</title>
  </head>
  <body>
    <ol>
      <li>The Beginner's Triumph.</li>
      <li>The Debugger's Dilemma</li>
    </ol>
  </body>
</html>
```

The `jinja_template` is simply a string variable that stores html with some expressions and statements.
The `context` variable stores a dictionary, with everything we previously put into the context.json file.
Next a Template gets instatiated from the `jinja_template` string. The render method is called, with the context as an argument. I.e., providing the render method access to the context dictionary.

#### Getting started with Jinja

Here is a link to the [Jinja Project](https://jinja.palletsprojects.com/en/3.1.x/) and this is a good [primer](https://realpython.com/primer-on-jinja-templating/)

Moving closer to production code, a `jinja_to_html` method might look something like this:

```python
from pathlib import Path
from json import load
from jinja2 import Template


class Site_Generator:
    """ Generate a static website from markdown files and jinja2 templates. """

    def __init__(self, context_file: str):
        """Initialize the site creator
        Args: context_file: name of the context file
        """
        with open(context_file, encoding="utf-8") as json_file:
            self.context = load(json_file)
            self.templates = Path.cwd().joinpath(self.context.get("templates_dir"))
            self.posts = Path.cwd().joinpath(self.context.get("posts_dir"))

    def jinja_to_html(self, jinja_file: str, html_file: str) -> None:
        """ Render a jinja template
            Args:   jinja_file: name of the template file
                    html_file: name of the target file
        """
        with self.templates.joinpath(jinja_file).open(encoding="utf-8") as src:
            code = Template(src.read(),
                            trim_blocks=True,   # remove whitespace
                            lstrip_blocks=True,  # remove leading whitespace
                            extensions=("jinja2.ext.do")  # allow do sttmnts
                            ).render(self.context)
            trg_path = Path.cwd().joinpath(self.context.get("site_dir"), html_file)
            trg_path.parent.mkdir(parents=True, exist_ok=True)
            with trg_path.open(mode="w", encoding="utf-8") as trg:
                trg.write(code)
                print(f"Generated: {trg_path}")
```

### HTML to Jinja

While it's certainly not the prettiest choice, https://www.w3schools.com/w3css/tryw3css_templates_blog.htm is a template rich enough to show how an HTML site template can easity be converted into jinja templates.
I saved this [html](https://www.w3schools.com/w3css/tryit.asp?filename=tryw3css_templates_blog&stacked=h) code in `templates/index.jinja` and replaced some of the html with jinja.

For instance, I changed the header to this:

```jinja
<!-- Header -->
<header class="w3-container w3-center w3-padding-32">
  <h1><b>{{ title }}</b></h1>
  <p>{{ description }}></p>
</header>
```

Next I replaced the three _Blog entry_ divs with this jinja for-loop:

```jinja
<!-- Blog entries -->
<div class="w3-col l8 s12">
  {% for post in content.posts if post.featured %}
  <!-- Blog entry -->
  <div class="w3-card-4 w3-margin w3-white">
    {% if post.cover %}
    <img src="/assets/images/{{ post.cover }}" style="width:50%">
    {% endif %}
    <div class="w3-container">
      <h3><b>{{ post.title }}</b></h3>
      <h5>{{ post.cove }}</h5>
    </div>
    <div class="w3-container">
      <p>{{ post.summary }}</p>
      <div class="w3-row">
        <div class="w3-col m8 s12">
          <p><button class="w3-button w3-padding-large w3-white w3-border"
              onclick="location.href='/{{ post.name }}.html'" type="button"><b>READ MORE Â»</b></button></p>
        </div>
      </div>
    </div>
  </div>
  {% endfor %}
  <!-- END BLOG ENTRIES -->
</div>
```

After adding three more key value pairs (_author_name, author_about, author_avatar_) to the context.json file, I modified the _About Card_ to this:

```jinja
<!-- About Card -->
<div class="w3-card w3-margin w3-margin-top">
  <img src="/assets/images/{{ author_avatar }}" style="width:50%">
  <div class="w3-container w3-white">
    <h4><b>{{ author_name }}</b></h4>
    <p>{{ author_about }}</p>
  </div>
</div>
<hr>
```

Next, I replaced the list of featured posts with this jinja loop:

```jinja
<!-- Posts -->
<div class="w3-card w3-margin">
  <div class="w3-container w3-padding">
    <h4>Popular Posts</h4>
  </div>
  <ul class="w3-ul w3-hoverable w3-white">
    {% for post in content.posts if not post.featured %}
    <li class="w3-padding-16" onclick="location.href='/{{ post.name }}.html'">
      {% if post.cover %}
      <img src="/assets/images/{{ post.cover }}" alt="Image" class="w3-left w3-margin-right" style="width:50px">
      {% endif %}
      <span class="w3-large">{{ post.title }}</span><br>
      <span>{{ post.summary }}</span>
    </li>
    {% endfor %}
  </ul>
</div>
```

Moreover, I replaced the hardcoded tag-list, with the categories of the posts as defined in the context.json file and cleaned up the footer.
Overall, the index.jinja file got a little shorter, which is absolutely a good thing.

You might be tempted, running this:

```python
Site_Creator("context.json").jinja_to_html("index.jinja", "index.html")
```

However, there is still a little bit of setup work required. Let's add a `generate_site` method to the `Site_Generator` class and run that instead.

```python
    def generate_site(self):
        """Generate the static website.
        1. Remove the site_dir and re-create it
        2. Copy the static directories
        3. Render the index page
        """
    site_dir = Path.cwd().joinpath(self.context.get("site_dir"))
    rmtree(site_dir, ignore_errors=True)
    site_dir.mkdir()
    for dir in self.context["static_dirs"]:
        copytree(dir, site_dir.joinpath(dir))
    self.jinja_to_html("index.jinja", "index.html")  # render index page
```

```python
if __name__ == "__main__":
    Site_Generator("context.json").generate_site()
```

## 4. Local Preview

To preview the just generated `index.html` file, install the __ritwickdey.liveserver__ VSCode extension, to _"launch a development local Server with live reload feature for static & dynamic pages"_.  
I also added this key/value pair to the ./.vscode/settings.json file: `"liveServer.settings.root": "/public"`, pointing the local webserver to the root directory. Starting the server (look at the bottom right in VSCode) brings up something like this:

<image>

Nice, but if you look closely, the page only contains metadata, information stored in the context,json file and there is still some work ahead of us. The markdown documents need to be converted into html and for that we need another jinja template.  
Once again, I started with the index.html file as a starting point and saved it as `templates/post.jinja`. At its core, it looks like this now:

```jinja
<!-- Header -->
<header class="w3-container w3-center w3-padding-32">
  <h1><b>{{ post.title }}</b></h1>
  <p>{{ post.summary }}</p>
</header>

<!-- Grid -->
<div class="w3-row">

  <!-- Post -->
  <div class="w3-card-4 w3-margin w3-white">
     {% if post.cover %}
        <img src="/assets/images/{{ post.cover }}" style="width:100%">
     {% endif %}

    <div class="w3-container">
      {{ post.text }}
    </div>
  </div>
  <hr>
  <!-- END Post -->
</div>
```

### Markdown to html
Converting Markdown to html is straightforward, after pip installing the markdown module:
```shell
pip install markdown
```

```python 
def md_to_html(self, file_name: str) -> str:
    """Convert a markdown file to html.
    Args: file_name: name of the markdown file
    Returns: html: the html content
    """
    with self.posts.joinpath(file_name).open(encoding="utf-8") as file:
        return markdown(file.read().strip(), extensions=['fenced_code', 'codehilite'])

```

## 5. Rendering Source Code Beautifully

The Markdown module has a [Code Hilite](https://python-markdown.github.io/extensions/code_hilite/) extension, which required `Pygments`, a generic syntax highlighter. Pygments was not installed as a dependency, but is just one more pip install away. 
We also need a cool colortheme, which can be previewed [here](https://pygments.org/styles/). I liked `dracula` and therefore ran these commands in terminal:

```shell
pip install Pygments
mkdir ./assets/css
pygmentize -S dracula -f html -a .codehilite > ./assets/css/dracula.css
```

The newly created dracula.css file needs to be put into the `post.jinja`, which at the very top now looks like this:
```jinja
<!DOCTYPE html>
<html>
<head>
  <title>{{post.title}}</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/css/dracula.css" />
  <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
  <style>
    body,h1,h2,h3,h4,h5 {font-family: "Raleway", sans-serif}
  </style>
</head>
```

To render all markdown posts, the Site_Generator's `generate_site` methods needs to be expanded, like shown below:
```python
def generate_site(self):
    """Generate the static website.
    1. Remove the site_dir and re-create it
    2. Copy the static directories
    3. Render the index page
    4. Render the posts
    """
    site_dir = Path.cwd().joinpath(self.context.get("site_dir"))
    rmtree(site_dir, ignore_errors=True)
    site_dir.mkdir()
    for dir in self.context["static_dirs"]:
        copytree(dir, site_dir.joinpath(dir))
    self.jinja_to_html("index.jinja", "index.html")  # render index page
    # render posts
    posts = self.context["content"]["posts"]
    k = len(posts)
    for i, post in enumerate(posts):
        post["text"] = self.md_to_html(f"{post['name']}.md")
        post["prev"] = posts[i - 1]["name"] if i > 0 else None
        post["next"] = posts[i + 1]["name"] if i < k-1 else None
        self.context["post"] = post
        self.jinja_to_html("post.jinja", f"{post['name']}.html")
    self.context["post"] = None
```        
After re-running `Site_Generator("context.json").generate_site()` html pages for all posts have been generated and source snippets within those pages is rendered beautifully.

## 6. Changes to the GitHub repository should trigger a rebuild/republish of the website.

To have github repository changes trigger a that all html pages are regenerated and republished we need a github repsoitory and a hosting provider. Let's start with the github repository.

I created a new repo on <https://github.com> and named it __static-site-generator__.
Locally, I ran these commands inside the VSCOde terminal:

```shell
git init
git branch -M main
git remote add origin git@github.com:wolfpaulus/static-site-generator.git
```
Not everything needs to be tracked in the repo. While the /public folder contains the generated html files, it does not belong into repo since the build process will generate those file. Therefore, I added this to the ./.gitignore file.

```text
.DS_Store
.venv/
public/
__pycache__/
*.pyc
```

The idea is that everytime a repo change is detected, `Site_Generator("context.json").generate_site()` is run. TO prepare for this, I added the following to the `main.py` script:

```python
if __name__ == "__main__":
    Site_Generator("context.json").generate_site()
```

Since I'm not checking in the _virtual environment_ ./.venv/, running `main.py` remotely would certainly fail, due to the missing 3rd party modules.Providing a `requirements.txt` file avaoids those problems:
```text
jinja2
markdown
Pygments
```
Now it's time to add everything to git, commit, and push.
Everything is in place now to build and host the site at [Cloudflare](https://www.cloudflare.com)

## 8. The public website should load really fast, but hosting should cost very little.

.. more soon ..